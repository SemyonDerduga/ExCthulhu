"""
API маршруты для получения данных.
"""

from fastapi import APIRouter, HTTPException
from fastapi.responses import JSONResponse
import asyncio
import logging
from typing import List, Dict, Any, Optional

from cthulhu_src.services.historical_data import MultiExchangeHistoricalService
from cthulhu_src.services.forecast import ForecastService
from cthulhu_src.services.exchange_manager import ExchangeManager
from cthulhu_src.services.cross_exchange_manager import get_free_transitions

logger = logging.getLogger("excthulhu")

router = APIRouter()


@router.get("/exchanges")
async def get_exchanges():
    """Получить список доступных бирж."""
    exchanges = [
        "binance", "yobit", "hollaex", "oceanex", "poloniex", 
        "upbit", "exmo"
    ]
    return {"exchanges": exchanges}


@router.get("/historical-data/{exchange}/{symbol}")
async def get_historical_data(
    exchange: str, 
    symbol: str, 
    hours: int = 24,
    format: str = "prices"
):
    """Получить исторические данные."""
    try:
        historical_service = MultiExchangeHistoricalService([exchange])
        
        if format == "prices":
            prices = await historical_service.services[exchange].get_price_history(
                symbol, hours=hours
            )
            
            if not prices:
                raise HTTPException(status_code=404, detail="Данные не найдены")
            
            return {
                "exchange": exchange,
                "symbol": symbol,
                "prices": prices,
                "count": len(prices)
            }
            
        elif format == "ohlcv":
            ohlcv_data = await historical_service.services[exchange].get_ohlcv(
                symbol, limit=100
            )
            
            if not ohlcv_data:
                raise HTTPException(status_code=404, detail="Данные не найдены")
            
            return {
                "exchange": exchange,
                "symbol": symbol,
                "ohlcv": ohlcv_data,
                "count": len(ohlcv_data)
            }
            
        elif format == "info":
            market_info = await historical_service.services[exchange].get_market_info(symbol)
            
            if not market_info:
                raise HTTPException(status_code=404, detail="Данные не найдены")
            
            return market_info
            
        await historical_service.close()
        
    except Exception as e:
        logger.error(f"Ошибка получения данных: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/forecast")
async def make_forecast(
    prices: List[float],
    methods: List[str] = ["mean"],
    horizons: List[int] = [5],
    lookback: int = 60
):
    """Сделать прогноз на основе исторических цен."""
    try:
        forecast_service = ForecastService(lookback=lookback)
        
        forecasts = []
        for method in methods:
            method_forecasts = forecast_service.predict(prices, horizons, method)
            forecasts.extend([
                {
                    "method": method,
                    "horizon": horizon,
                    "mu": forecast.mu,
                    "sigma": forecast.sigma,
                    "confidence": max(0.0, 1.0 - (forecast.sigma / abs(forecast.mu))) if forecast.sigma > 0 else 1.0
                }
                for horizon, forecast in zip(horizons, method_forecasts)
            ])
        
        return {
            "prices": prices,
            "forecasts": forecasts,
            "lookback": lookback
        }
        
    except Exception as e:
        logger.error(f"Ошибка прогнозирования: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/arbitrage")
async def find_arbitrage(
    start_node: str,
    amount: float = 1.0,
    max_depth: int = 4,
    exchanges: List[str] = ["binance", "yobit"],
    algorithm: str = "dfs"
):
    """Найти арбитражные возможности."""
    try:
        # Загружаем данные с бирж
        exchange_manager = ExchangeManager(exchanges)
        
        try:
            pairs = await exchange_manager.fetch_prices()
        finally:
            await exchange_manager.close()
        
        pairs += get_free_transitions(exchanges)
        
        # Создаем граф
        from collections import defaultdict
        adj_dict = defaultdict(list)
        for pair in pairs:
            adj_dict[pair.currency_from].append(pair)
        
        currency_list = list(adj_dict.keys())
        
        if start_node not in currency_list:
            raise HTTPException(status_code=404, detail="Стартовая валюта не найдена")
        
        adj_list = [
            {
                currency_list.index(pair.currency_to): pair.trade_book
                for pair in adj_dict[currency_from]
            }
            for currency_from in currency_list
        ]
        
        start_node_id = currency_list.index(start_node)
        
        # Ищем пути
        from cthulhu_src.services.processor import find_paths
        paths = find_paths(
            adj_list, start_node_id, amount,
            max_depth=max_depth
        )
        
        # Форматируем результаты
        opportunities = []
        for path in paths:
            if len(path) > 1:
                final_amount = path[-1][1]
                profit_percent = ((final_amount - amount) / amount) * 100
                
                opportunities.append({
                    "path": [f"{node[0]}" for node in path],
                    "profit_percent": profit_percent,
                    "start_amount": amount,
                    "final_amount": final_amount
                })
        
        return {
            "opportunities": opportunities,
            "total_found": len(opportunities)
        }
        
    except Exception as e:
        logger.error(f"Ошибка поиска арбитража: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/forecast-arbitrage")
async def forecast_arbitrage_integrated(
    start_node: str,
    amount: float = 1.0,
    max_depth: int = 4,
    exchanges: List[str] = ["binance", "yobit"],
    auto_fetch_history: bool = True,
    history_symbol: Optional[str] = None,
    history_hours: int = 24,
    forecast_method: str = "mean",
    forecast_horizon: int = 5,
    lookback: int = 60
):
    """Интегрированный поиск арбитража с прогнозированием."""
    try:
        # Получаем исторические данные если нужно
        historical_prices = None
        if auto_fetch_history:
            if not history_symbol:
                currency = start_node.split('_')[-1] if '_' in start_node else 'BTC'
                history_symbol = f"{currency}/USDT"
            
            historical_service = MultiExchangeHistoricalService([exchanges[0]])
            historical_prices = await historical_service.services[exchanges[0]].get_price_history(
                history_symbol, hours=history_hours
            )
            await historical_service.close()
        
        # Ищем арбитраж
        arbitrage_result = await find_arbitrage(start_node, amount, max_depth, exchanges)
        
        # Делаем прогноз если есть данные
        forecast_result = None
        if historical_prices:
            forecast_result = await make_forecast(
                historical_prices, [forecast_method], [forecast_horizon], lookback
            )
        
        return {
            "arbitrage": arbitrage_result,
            "forecast": forecast_result,
            "historical_prices": historical_prices,
            "history_symbol": history_symbol
        }
        
    except Exception as e:
        logger.error(f"Ошибка интегрированного поиска: {e}")
        raise HTTPException(status_code=500, detail=str(e)) 